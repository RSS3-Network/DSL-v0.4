"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type AbiChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    contentType: BigInt!
}

input AbiChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    contentType: BigInt
    contentType_not: BigInt
    contentType_gt: BigInt
    contentType_lt: BigInt
    contentType_gte: BigInt
    contentType_lte: BigInt
    contentType_in: [BigInt!]
    contentType_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [AbiChanged_filter]
    or: [AbiChanged_filter]
}

enum AbiChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    contentType
}

type Account {
    id: ID!
    domains(
        skip: Int = 0
        first: Int = 100
        orderBy: Domain_orderBy
        orderDirection: OrderDirection
        where: Domain_filter
    ): [Domain!]!
    wrappedDomains(
        skip: Int = 0
        first: Int = 100
        orderBy: WrappedDomain_orderBy
        orderDirection: OrderDirection
        where: WrappedDomain_filter
    ): [WrappedDomain!]
    registrations(
        skip: Int = 0
        first: Int = 100
        orderBy: Registration_orderBy
        orderDirection: OrderDirection
        where: Registration_filter
    ): [Registration!]
}

input Account_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domains_: Domain_filter
    wrappedDomains_: WrappedDomain_filter
    registrations_: Registration_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Account_filter]
    or: [Account_filter]
}

enum Account_orderBy {
    id
    domains
    wrappedDomains
    registrations
}

type AddrChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    addr: Account!
}

input AddrChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    addr: String
    addr_not: String
    addr_gt: String
    addr_lt: String
    addr_gte: String
    addr_lte: String
    addr_in: [String!]
    addr_not_in: [String!]
    addr_contains: String
    addr_contains_nocase: String
    addr_not_contains: String
    addr_not_contains_nocase: String
    addr_starts_with: String
    addr_starts_with_nocase: String
    addr_not_starts_with: String
    addr_not_starts_with_nocase: String
    addr_ends_with: String
    addr_ends_with_nocase: String
    addr_not_ends_with: String
    addr_not_ends_with_nocase: String
    addr_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [AddrChanged_filter]
    or: [AddrChanged_filter]
}

enum AddrChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    addr
    addr__id
}

type AuthorisationChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    owner: Bytes!
    target: Bytes!
    isAuthorized: Boolean!
}

input AuthorisationChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    owner: Bytes
    owner_not: Bytes
    owner_gt: Bytes
    owner_lt: Bytes
    owner_gte: Bytes
    owner_lte: Bytes
    owner_in: [Bytes!]
    owner_not_in: [Bytes!]
    owner_contains: Bytes
    owner_not_contains: Bytes
    target: Bytes
    target_not: Bytes
    target_gt: Bytes
    target_lt: Bytes
    target_gte: Bytes
    target_lte: Bytes
    target_in: [Bytes!]
    target_not_in: [Bytes!]
    target_contains: Bytes
    target_not_contains: Bytes
    isAuthorized: Boolean
    isAuthorized_not: Boolean
    isAuthorized_in: [Boolean!]
    isAuthorized_not_in: [Boolean!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [AuthorisationChanged_filter]
    or: [AuthorisationChanged_filter]
}

enum AuthorisationChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    owner
    target
    isAuthorized
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

type ContenthashChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    hash: Bytes!
}

input ContenthashChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    hash: Bytes
    hash_not: Bytes
    hash_gt: Bytes
    hash_lt: Bytes
    hash_gte: Bytes
    hash_lte: Bytes
    hash_in: [Bytes!]
    hash_not_in: [Bytes!]
    hash_contains: Bytes
    hash_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [ContenthashChanged_filter]
    or: [ContenthashChanged_filter]
}

enum ContenthashChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    hash
}

type Domain {
    id: ID!
    name: String
    labelName: String
    labelhash: Bytes
    parent: Domain
    subdomains(
        skip: Int = 0
        first: Int = 100
        orderBy: Domain_orderBy
        orderDirection: OrderDirection
        where: Domain_filter
    ): [Domain!]!
    subdomainCount: Int!
    resolvedAddress: Account
    owner: Account!
    resolver: Resolver
    ttl: BigInt
    isMigrated: Boolean!
    createdAt: BigInt!
    events(
        skip: Int = 0
        first: Int = 100
        orderBy: DomainEvent_orderBy
        orderDirection: OrderDirection
        where: DomainEvent_filter
    ): [DomainEvent!]!
    registration: Registration
    wrappedDomain: WrappedDomain
}

interface DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
}

input DomainEvent_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [DomainEvent_filter]
    or: [DomainEvent_filter]
}

enum DomainEvent_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
}

input Domain_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    labelName: String
    labelName_not: String
    labelName_gt: String
    labelName_lt: String
    labelName_gte: String
    labelName_lte: String
    labelName_in: [String!]
    labelName_not_in: [String!]
    labelName_contains: String
    labelName_contains_nocase: String
    labelName_not_contains: String
    labelName_not_contains_nocase: String
    labelName_starts_with: String
    labelName_starts_with_nocase: String
    labelName_not_starts_with: String
    labelName_not_starts_with_nocase: String
    labelName_ends_with: String
    labelName_ends_with_nocase: String
    labelName_not_ends_with: String
    labelName_not_ends_with_nocase: String
    labelhash: Bytes
    labelhash_not: Bytes
    labelhash_gt: Bytes
    labelhash_lt: Bytes
    labelhash_gte: Bytes
    labelhash_lte: Bytes
    labelhash_in: [Bytes!]
    labelhash_not_in: [Bytes!]
    labelhash_contains: Bytes
    labelhash_not_contains: Bytes
    parent: String
    parent_not: String
    parent_gt: String
    parent_lt: String
    parent_gte: String
    parent_lte: String
    parent_in: [String!]
    parent_not_in: [String!]
    parent_contains: String
    parent_contains_nocase: String
    parent_not_contains: String
    parent_not_contains_nocase: String
    parent_starts_with: String
    parent_starts_with_nocase: String
    parent_not_starts_with: String
    parent_not_starts_with_nocase: String
    parent_ends_with: String
    parent_ends_with_nocase: String
    parent_not_ends_with: String
    parent_not_ends_with_nocase: String
    parent_: Domain_filter
    subdomains_: Domain_filter
    subdomainCount: Int
    subdomainCount_not: Int
    subdomainCount_gt: Int
    subdomainCount_lt: Int
    subdomainCount_gte: Int
    subdomainCount_lte: Int
    subdomainCount_in: [Int!]
    subdomainCount_not_in: [Int!]
    resolvedAddress: String
    resolvedAddress_not: String
    resolvedAddress_gt: String
    resolvedAddress_lt: String
    resolvedAddress_gte: String
    resolvedAddress_lte: String
    resolvedAddress_in: [String!]
    resolvedAddress_not_in: [String!]
    resolvedAddress_contains: String
    resolvedAddress_contains_nocase: String
    resolvedAddress_not_contains: String
    resolvedAddress_not_contains_nocase: String
    resolvedAddress_starts_with: String
    resolvedAddress_starts_with_nocase: String
    resolvedAddress_not_starts_with: String
    resolvedAddress_not_starts_with_nocase: String
    resolvedAddress_ends_with: String
    resolvedAddress_ends_with_nocase: String
    resolvedAddress_not_ends_with: String
    resolvedAddress_not_ends_with_nocase: String
    resolvedAddress_: Account_filter
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    ttl: BigInt
    ttl_not: BigInt
    ttl_gt: BigInt
    ttl_lt: BigInt
    ttl_gte: BigInt
    ttl_lte: BigInt
    ttl_in: [BigInt!]
    ttl_not_in: [BigInt!]
    isMigrated: Boolean
    isMigrated_not: Boolean
    isMigrated_in: [Boolean!]
    isMigrated_not_in: [Boolean!]
    createdAt: BigInt
    createdAt_not: BigInt
    createdAt_gt: BigInt
    createdAt_lt: BigInt
    createdAt_gte: BigInt
    createdAt_lte: BigInt
    createdAt_in: [BigInt!]
    createdAt_not_in: [BigInt!]
    events_: DomainEvent_filter
    registration_: Registration_filter
    wrappedDomain_: WrappedDomain_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Domain_filter]
    or: [Domain_filter]
}

enum Domain_orderBy {
    id
    name
    labelName
    labelhash
    parent
    parent__id
    parent__name
    parent__labelName
    parent__labelhash
    parent__subdomainCount
    parent__ttl
    parent__isMigrated
    parent__createdAt
    subdomains
    subdomainCount
    resolvedAddress
    resolvedAddress__id
    owner
    owner__id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    ttl
    isMigrated
    createdAt
    events
    registration
    registration__id
    registration__registrationDate
    registration__expiryDate
    registration__cost
    registration__labelName
    wrappedDomain
    wrappedDomain__id
    wrappedDomain__expiryDate
    wrappedDomain__fuses
    wrappedDomain__name
}

type ExpiryExtended implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    expiryDate: BigInt!
}

input ExpiryExtended_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [ExpiryExtended_filter]
    or: [ExpiryExtended_filter]
}

enum ExpiryExtended_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    expiryDate
}

type FusesSet implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    fuses: Int!
}

input FusesSet_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    fuses: Int
    fuses_not: Int
    fuses_gt: Int
    fuses_lt: Int
    fuses_gte: Int
    fuses_lte: Int
    fuses_in: [Int!]
    fuses_not_in: [Int!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [FusesSet_filter]
    or: [FusesSet_filter]
}

enum FusesSet_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    fuses
}

type InterfaceChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    interfaceID: Bytes!
    implementer: Bytes!
}

input InterfaceChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    interfaceID: Bytes
    interfaceID_not: Bytes
    interfaceID_gt: Bytes
    interfaceID_lt: Bytes
    interfaceID_gte: Bytes
    interfaceID_lte: Bytes
    interfaceID_in: [Bytes!]
    interfaceID_not_in: [Bytes!]
    interfaceID_contains: Bytes
    interfaceID_not_contains: Bytes
    implementer: Bytes
    implementer_not: Bytes
    implementer_gt: Bytes
    implementer_lt: Bytes
    implementer_gte: Bytes
    implementer_lte: Bytes
    implementer_in: [Bytes!]
    implementer_not_in: [Bytes!]
    implementer_contains: Bytes
    implementer_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [InterfaceChanged_filter]
    or: [InterfaceChanged_filter]
}

enum InterfaceChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    interfaceID
    implementer
}

type MulticoinAddrChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    coinType: BigInt!
    addr: Bytes!
}

input MulticoinAddrChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    coinType: BigInt
    coinType_not: BigInt
    coinType_gt: BigInt
    coinType_lt: BigInt
    coinType_gte: BigInt
    coinType_lte: BigInt
    coinType_in: [BigInt!]
    coinType_not_in: [BigInt!]
    addr: Bytes
    addr_not: Bytes
    addr_gt: Bytes
    addr_lt: Bytes
    addr_gte: Bytes
    addr_lte: Bytes
    addr_in: [Bytes!]
    addr_not_in: [Bytes!]
    addr_contains: Bytes
    addr_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [MulticoinAddrChanged_filter]
    or: [MulticoinAddrChanged_filter]
}

enum MulticoinAddrChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    coinType
    addr
}

type NameChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    name: String!
}

input NameChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameChanged_filter]
    or: [NameChanged_filter]
}

enum NameChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    name
}

type NameRegistered implements RegistrationEvent {
    id: ID!
    registration: Registration!
    blockNumber: Int!
    transactionID: Bytes!
    registrant: Account!
    expiryDate: BigInt!
}

input NameRegistered_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    registration: String
    registration_not: String
    registration_gt: String
    registration_lt: String
    registration_gte: String
    registration_lte: String
    registration_in: [String!]
    registration_not_in: [String!]
    registration_contains: String
    registration_contains_nocase: String
    registration_not_contains: String
    registration_not_contains_nocase: String
    registration_starts_with: String
    registration_starts_with_nocase: String
    registration_not_starts_with: String
    registration_not_starts_with_nocase: String
    registration_ends_with: String
    registration_ends_with_nocase: String
    registration_not_ends_with: String
    registration_not_ends_with_nocase: String
    registration_: Registration_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    registrant: String
    registrant_not: String
    registrant_gt: String
    registrant_lt: String
    registrant_gte: String
    registrant_lte: String
    registrant_in: [String!]
    registrant_not_in: [String!]
    registrant_contains: String
    registrant_contains_nocase: String
    registrant_not_contains: String
    registrant_not_contains_nocase: String
    registrant_starts_with: String
    registrant_starts_with_nocase: String
    registrant_not_starts_with: String
    registrant_not_starts_with_nocase: String
    registrant_ends_with: String
    registrant_ends_with_nocase: String
    registrant_not_ends_with: String
    registrant_not_ends_with_nocase: String
    registrant_: Account_filter
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameRegistered_filter]
    or: [NameRegistered_filter]
}

enum NameRegistered_orderBy {
    id
    registration
    registration__id
    registration__registrationDate
    registration__expiryDate
    registration__cost
    registration__labelName
    blockNumber
    transactionID
    registrant
    registrant__id
    expiryDate
}

type NameRenewed implements RegistrationEvent {
    id: ID!
    registration: Registration!
    blockNumber: Int!
    transactionID: Bytes!
    expiryDate: BigInt!
}

input NameRenewed_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    registration: String
    registration_not: String
    registration_gt: String
    registration_lt: String
    registration_gte: String
    registration_lte: String
    registration_in: [String!]
    registration_not_in: [String!]
    registration_contains: String
    registration_contains_nocase: String
    registration_not_contains: String
    registration_not_contains_nocase: String
    registration_starts_with: String
    registration_starts_with_nocase: String
    registration_not_starts_with: String
    registration_not_starts_with_nocase: String
    registration_ends_with: String
    registration_ends_with_nocase: String
    registration_not_ends_with: String
    registration_not_ends_with_nocase: String
    registration_: Registration_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameRenewed_filter]
    or: [NameRenewed_filter]
}

enum NameRenewed_orderBy {
    id
    registration
    registration__id
    registration__registrationDate
    registration__expiryDate
    registration__cost
    registration__labelName
    blockNumber
    transactionID
    expiryDate
}

type NameTransferred implements RegistrationEvent {
    id: ID!
    registration: Registration!
    blockNumber: Int!
    transactionID: Bytes!
    newOwner: Account!
}

input NameTransferred_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    registration: String
    registration_not: String
    registration_gt: String
    registration_lt: String
    registration_gte: String
    registration_lte: String
    registration_in: [String!]
    registration_not_in: [String!]
    registration_contains: String
    registration_contains_nocase: String
    registration_not_contains: String
    registration_not_contains_nocase: String
    registration_starts_with: String
    registration_starts_with_nocase: String
    registration_not_starts_with: String
    registration_not_starts_with_nocase: String
    registration_ends_with: String
    registration_ends_with_nocase: String
    registration_not_ends_with: String
    registration_not_ends_with_nocase: String
    registration_: Registration_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    newOwner: String
    newOwner_not: String
    newOwner_gt: String
    newOwner_lt: String
    newOwner_gte: String
    newOwner_lte: String
    newOwner_in: [String!]
    newOwner_not_in: [String!]
    newOwner_contains: String
    newOwner_contains_nocase: String
    newOwner_not_contains: String
    newOwner_not_contains_nocase: String
    newOwner_starts_with: String
    newOwner_starts_with_nocase: String
    newOwner_not_starts_with: String
    newOwner_not_starts_with_nocase: String
    newOwner_ends_with: String
    newOwner_ends_with_nocase: String
    newOwner_not_ends_with: String
    newOwner_not_ends_with_nocase: String
    newOwner_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameTransferred_filter]
    or: [NameTransferred_filter]
}

enum NameTransferred_orderBy {
    id
    registration
    registration__id
    registration__registrationDate
    registration__expiryDate
    registration__cost
    registration__labelName
    blockNumber
    transactionID
    newOwner
    newOwner__id
}

type NameUnwrapped implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    owner: Account!
}

input NameUnwrapped_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameUnwrapped_filter]
    or: [NameUnwrapped_filter]
}

enum NameUnwrapped_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    owner
    owner__id
}

type NameWrapped implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    name: String
    fuses: Int!
    owner: Account!
    expiryDate: BigInt!
}

input NameWrapped_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    fuses: Int
    fuses_not: Int
    fuses_gt: Int
    fuses_lt: Int
    fuses_gte: Int
    fuses_lte: Int
    fuses_in: [Int!]
    fuses_not_in: [Int!]
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NameWrapped_filter]
    or: [NameWrapped_filter]
}

enum NameWrapped_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    name
    fuses
    owner
    owner__id
    expiryDate
}

type NewOwner implements DomainEvent {
    id: ID!
    parentDomain: Domain!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    owner: Account!
}

input NewOwner_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    parentDomain: String
    parentDomain_not: String
    parentDomain_gt: String
    parentDomain_lt: String
    parentDomain_gte: String
    parentDomain_lte: String
    parentDomain_in: [String!]
    parentDomain_not_in: [String!]
    parentDomain_contains: String
    parentDomain_contains_nocase: String
    parentDomain_not_contains: String
    parentDomain_not_contains_nocase: String
    parentDomain_starts_with: String
    parentDomain_starts_with_nocase: String
    parentDomain_not_starts_with: String
    parentDomain_not_starts_with_nocase: String
    parentDomain_ends_with: String
    parentDomain_ends_with_nocase: String
    parentDomain_not_ends_with: String
    parentDomain_not_ends_with_nocase: String
    parentDomain_: Domain_filter
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NewOwner_filter]
    or: [NewOwner_filter]
}

enum NewOwner_orderBy {
    id
    parentDomain
    parentDomain__id
    parentDomain__name
    parentDomain__labelName
    parentDomain__labelhash
    parentDomain__subdomainCount
    parentDomain__ttl
    parentDomain__isMigrated
    parentDomain__createdAt
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    owner
    owner__id
}

type NewResolver implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    resolver: Resolver!
}

input NewResolver_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NewResolver_filter]
    or: [NewResolver_filter]
}

enum NewResolver_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
}

type NewTTL implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    ttl: BigInt!
}

input NewTTL_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    ttl: BigInt
    ttl_not: BigInt
    ttl_gt: BigInt
    ttl_lt: BigInt
    ttl_gte: BigInt
    ttl_lte: BigInt
    ttl_in: [BigInt!]
    ttl_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [NewTTL_filter]
    or: [NewTTL_filter]
}

enum NewTTL_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    ttl
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type PubkeyChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    x: Bytes!
    y: Bytes!
}

input PubkeyChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    x: Bytes
    x_not: Bytes
    x_gt: Bytes
    x_lt: Bytes
    x_gte: Bytes
    x_lte: Bytes
    x_in: [Bytes!]
    x_not_in: [Bytes!]
    x_contains: Bytes
    x_not_contains: Bytes
    y: Bytes
    y_not: Bytes
    y_gt: Bytes
    y_lt: Bytes
    y_gte: Bytes
    y_lte: Bytes
    y_in: [Bytes!]
    y_not_in: [Bytes!]
    y_contains: Bytes
    y_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PubkeyChanged_filter]
    or: [PubkeyChanged_filter]
}

enum PubkeyChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    x
    y
}

type Query {
    domain(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Domain
    domains(
        skip: Int = 0
        first: Int = 100
        orderBy: Domain_orderBy
        orderDirection: OrderDirection
        where: Domain_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Domain!]!
    transfer(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transfer
    transfers(
        skip: Int = 0
        first: Int = 100
        orderBy: Transfer_orderBy
        orderDirection: OrderDirection
        where: Transfer_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Transfer!]!
    newOwner(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewOwner
    newOwners(
        skip: Int = 0
        first: Int = 100
        orderBy: NewOwner_orderBy
        orderDirection: OrderDirection
        where: NewOwner_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewOwner!]!
    newResolver(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewResolver
    newResolvers(
        skip: Int = 0
        first: Int = 100
        orderBy: NewResolver_orderBy
        orderDirection: OrderDirection
        where: NewResolver_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewResolver!]!
    newTTL(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewTTL
    newTTLs(
        skip: Int = 0
        first: Int = 100
        orderBy: NewTTL_orderBy
        orderDirection: OrderDirection
        where: NewTTL_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewTTL!]!
    wrappedTransfer(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedTransfer
    wrappedTransfers(
        skip: Int = 0
        first: Int = 100
        orderBy: WrappedTransfer_orderBy
        orderDirection: OrderDirection
        where: WrappedTransfer_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [WrappedTransfer!]!
    nameWrapped(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameWrapped
    nameWrappeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameWrapped_orderBy
        orderDirection: OrderDirection
        where: NameWrapped_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameWrapped!]!
    nameUnwrapped(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameUnwrapped
    nameUnwrappeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameUnwrapped_orderBy
        orderDirection: OrderDirection
        where: NameUnwrapped_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameUnwrapped!]!
    fusesSet(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FusesSet
    fusesSets(
        skip: Int = 0
        first: Int = 100
        orderBy: FusesSet_orderBy
        orderDirection: OrderDirection
        where: FusesSet_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [FusesSet!]!
    expiryExtended(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ExpiryExtended
    expiryExtendeds(
        skip: Int = 0
        first: Int = 100
        orderBy: ExpiryExtended_orderBy
        orderDirection: OrderDirection
        where: ExpiryExtended_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ExpiryExtended!]!
    registration(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Registration
    registrations(
        skip: Int = 0
        first: Int = 100
        orderBy: Registration_orderBy
        orderDirection: OrderDirection
        where: Registration_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Registration!]!
    nameRegistered(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameRegistered
    nameRegistereds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameRegistered_orderBy
        orderDirection: OrderDirection
        where: NameRegistered_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameRegistered!]!
    nameRenewed(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameRenewed
    nameReneweds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameRenewed_orderBy
        orderDirection: OrderDirection
        where: NameRenewed_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameRenewed!]!
    nameTransferred(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameTransferred
    nameTransferreds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameTransferred_orderBy
        orderDirection: OrderDirection
        where: NameTransferred_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameTransferred!]!
    wrappedDomain(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedDomain
    wrappedDomains(
        skip: Int = 0
        first: Int = 100
        orderBy: WrappedDomain_orderBy
        orderDirection: OrderDirection
        where: WrappedDomain_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [WrappedDomain!]!
    account(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        skip: Int = 0
        first: Int = 100
        orderBy: Account_orderBy
        orderDirection: OrderDirection
        where: Account_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Account!]!
    resolver(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Resolver
    resolvers(
        skip: Int = 0
        first: Int = 100
        orderBy: Resolver_orderBy
        orderDirection: OrderDirection
        where: Resolver_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Resolver!]!
    addrChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddrChanged
    addrChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AddrChanged_orderBy
        orderDirection: OrderDirection
        where: AddrChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AddrChanged!]!
    multicoinAddrChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MulticoinAddrChanged
    multicoinAddrChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: MulticoinAddrChanged_orderBy
        orderDirection: OrderDirection
        where: MulticoinAddrChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [MulticoinAddrChanged!]!
    nameChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameChanged
    nameChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameChanged_orderBy
        orderDirection: OrderDirection
        where: NameChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameChanged!]!
    abiChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AbiChanged
    abiChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AbiChanged_orderBy
        orderDirection: OrderDirection
        where: AbiChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AbiChanged!]!
    pubkeyChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PubkeyChanged
    pubkeyChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: PubkeyChanged_orderBy
        orderDirection: OrderDirection
        where: PubkeyChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PubkeyChanged!]!
    textChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TextChanged
    textChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: TextChanged_orderBy
        orderDirection: OrderDirection
        where: TextChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [TextChanged!]!
    contenthashChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ContenthashChanged
    contenthashChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: ContenthashChanged_orderBy
        orderDirection: OrderDirection
        where: ContenthashChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ContenthashChanged!]!
    interfaceChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): InterfaceChanged
    interfaceChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: InterfaceChanged_orderBy
        orderDirection: OrderDirection
        where: InterfaceChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [InterfaceChanged!]!
    authorisationChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuthorisationChanged
    authorisationChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AuthorisationChanged_orderBy
        orderDirection: OrderDirection
        where: AuthorisationChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AuthorisationChanged!]!
    versionChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VersionChanged
    versionChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: VersionChanged_orderBy
        orderDirection: OrderDirection
        where: VersionChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [VersionChanged!]!
    domainEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DomainEvent
    domainEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: DomainEvent_orderBy
        orderDirection: OrderDirection
        where: DomainEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [DomainEvent!]!
    registrationEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegistrationEvent
    registrationEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: RegistrationEvent_orderBy
        orderDirection: OrderDirection
        where: RegistrationEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [RegistrationEvent!]!
    resolverEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ResolverEvent
    resolverEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: ResolverEvent_orderBy
        orderDirection: OrderDirection
        where: ResolverEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ResolverEvent!]!

    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

type Registration {
    id: ID!
    domain: Domain!
    registrationDate: BigInt!
    expiryDate: BigInt!
    cost: BigInt
    registrant: Account!
    labelName: String
    events(
        skip: Int = 0
        first: Int = 100
        orderBy: RegistrationEvent_orderBy
        orderDirection: OrderDirection
        where: RegistrationEvent_filter
    ): [RegistrationEvent!]!
}

interface RegistrationEvent {
    id: ID!
    registration: Registration!
    blockNumber: Int!
    transactionID: Bytes!
}

input RegistrationEvent_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    registration: String
    registration_not: String
    registration_gt: String
    registration_lt: String
    registration_gte: String
    registration_lte: String
    registration_in: [String!]
    registration_not_in: [String!]
    registration_contains: String
    registration_contains_nocase: String
    registration_not_contains: String
    registration_not_contains_nocase: String
    registration_starts_with: String
    registration_starts_with_nocase: String
    registration_not_starts_with: String
    registration_not_starts_with_nocase: String
    registration_ends_with: String
    registration_ends_with_nocase: String
    registration_not_ends_with: String
    registration_not_ends_with_nocase: String
    registration_: Registration_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [RegistrationEvent_filter]
    or: [RegistrationEvent_filter]
}

enum RegistrationEvent_orderBy {
    id
    registration
    registration__id
    registration__registrationDate
    registration__expiryDate
    registration__cost
    registration__labelName
    blockNumber
    transactionID
}

input Registration_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    registrationDate: BigInt
    registrationDate_not: BigInt
    registrationDate_gt: BigInt
    registrationDate_lt: BigInt
    registrationDate_gte: BigInt
    registrationDate_lte: BigInt
    registrationDate_in: [BigInt!]
    registrationDate_not_in: [BigInt!]
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]
    cost: BigInt
    cost_not: BigInt
    cost_gt: BigInt
    cost_lt: BigInt
    cost_gte: BigInt
    cost_lte: BigInt
    cost_in: [BigInt!]
    cost_not_in: [BigInt!]
    registrant: String
    registrant_not: String
    registrant_gt: String
    registrant_lt: String
    registrant_gte: String
    registrant_lte: String
    registrant_in: [String!]
    registrant_not_in: [String!]
    registrant_contains: String
    registrant_contains_nocase: String
    registrant_not_contains: String
    registrant_not_contains_nocase: String
    registrant_starts_with: String
    registrant_starts_with_nocase: String
    registrant_not_starts_with: String
    registrant_not_starts_with_nocase: String
    registrant_ends_with: String
    registrant_ends_with_nocase: String
    registrant_not_ends_with: String
    registrant_not_ends_with_nocase: String
    registrant_: Account_filter
    labelName: String
    labelName_not: String
    labelName_gt: String
    labelName_lt: String
    labelName_gte: String
    labelName_lte: String
    labelName_in: [String!]
    labelName_not_in: [String!]
    labelName_contains: String
    labelName_contains_nocase: String
    labelName_not_contains: String
    labelName_not_contains_nocase: String
    labelName_starts_with: String
    labelName_starts_with_nocase: String
    labelName_not_starts_with: String
    labelName_not_starts_with_nocase: String
    labelName_ends_with: String
    labelName_ends_with_nocase: String
    labelName_not_ends_with: String
    labelName_not_ends_with_nocase: String
    events_: RegistrationEvent_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Registration_filter]
    or: [Registration_filter]
}

enum Registration_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    registrationDate
    expiryDate
    cost
    registrant
    registrant__id
    labelName
    events
}

type Resolver {
    id: ID!
    domain: Domain
    address: Bytes!
    addr: Account
    contentHash: Bytes
    texts: [String!]
    coinTypes: [BigInt!]
    events(
        skip: Int = 0
        first: Int = 100
        orderBy: ResolverEvent_orderBy
        orderDirection: OrderDirection
        where: ResolverEvent_filter
    ): [ResolverEvent!]!
}

interface ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
}

input ResolverEvent_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [ResolverEvent_filter]
    or: [ResolverEvent_filter]
}

enum ResolverEvent_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
}

input Resolver_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    address: Bytes
    address_not: Bytes
    address_gt: Bytes
    address_lt: Bytes
    address_gte: Bytes
    address_lte: Bytes
    address_in: [Bytes!]
    address_not_in: [Bytes!]
    address_contains: Bytes
    address_not_contains: Bytes
    addr: String
    addr_not: String
    addr_gt: String
    addr_lt: String
    addr_gte: String
    addr_lte: String
    addr_in: [String!]
    addr_not_in: [String!]
    addr_contains: String
    addr_contains_nocase: String
    addr_not_contains: String
    addr_not_contains_nocase: String
    addr_starts_with: String
    addr_starts_with_nocase: String
    addr_not_starts_with: String
    addr_not_starts_with_nocase: String
    addr_ends_with: String
    addr_ends_with_nocase: String
    addr_not_ends_with: String
    addr_not_ends_with_nocase: String
    addr_: Account_filter
    contentHash: Bytes
    contentHash_not: Bytes
    contentHash_gt: Bytes
    contentHash_lt: Bytes
    contentHash_gte: Bytes
    contentHash_lte: Bytes
    contentHash_in: [Bytes!]
    contentHash_not_in: [Bytes!]
    contentHash_contains: Bytes
    contentHash_not_contains: Bytes
    texts: [String!]
    texts_not: [String!]
    texts_contains: [String!]
    texts_contains_nocase: [String!]
    texts_not_contains: [String!]
    texts_not_contains_nocase: [String!]
    coinTypes: [BigInt!]
    coinTypes_not: [BigInt!]
    coinTypes_contains: [BigInt!]
    coinTypes_contains_nocase: [BigInt!]
    coinTypes_not_contains: [BigInt!]
    coinTypes_not_contains_nocase: [BigInt!]
    events_: ResolverEvent_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Resolver_filter]
    or: [Resolver_filter]
}

enum Resolver_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    address
    addr
    addr__id
    contentHash
    texts
    coinTypes
    events
}

type Subscription {
    domain(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Domain
    domains(
        skip: Int = 0
        first: Int = 100
        orderBy: Domain_orderBy
        orderDirection: OrderDirection
        where: Domain_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Domain!]!
    transfer(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transfer
    transfers(
        skip: Int = 0
        first: Int = 100
        orderBy: Transfer_orderBy
        orderDirection: OrderDirection
        where: Transfer_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Transfer!]!
    newOwner(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewOwner
    newOwners(
        skip: Int = 0
        first: Int = 100
        orderBy: NewOwner_orderBy
        orderDirection: OrderDirection
        where: NewOwner_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewOwner!]!
    newResolver(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewResolver
    newResolvers(
        skip: Int = 0
        first: Int = 100
        orderBy: NewResolver_orderBy
        orderDirection: OrderDirection
        where: NewResolver_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewResolver!]!
    newTTL(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NewTTL
    newTTLs(
        skip: Int = 0
        first: Int = 100
        orderBy: NewTTL_orderBy
        orderDirection: OrderDirection
        where: NewTTL_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NewTTL!]!
    wrappedTransfer(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedTransfer
    wrappedTransfers(
        skip: Int = 0
        first: Int = 100
        orderBy: WrappedTransfer_orderBy
        orderDirection: OrderDirection
        where: WrappedTransfer_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [WrappedTransfer!]!
    nameWrapped(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameWrapped
    nameWrappeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameWrapped_orderBy
        orderDirection: OrderDirection
        where: NameWrapped_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameWrapped!]!
    nameUnwrapped(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameUnwrapped
    nameUnwrappeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameUnwrapped_orderBy
        orderDirection: OrderDirection
        where: NameUnwrapped_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameUnwrapped!]!
    fusesSet(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FusesSet
    fusesSets(
        skip: Int = 0
        first: Int = 100
        orderBy: FusesSet_orderBy
        orderDirection: OrderDirection
        where: FusesSet_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [FusesSet!]!
    expiryExtended(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ExpiryExtended
    expiryExtendeds(
        skip: Int = 0
        first: Int = 100
        orderBy: ExpiryExtended_orderBy
        orderDirection: OrderDirection
        where: ExpiryExtended_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ExpiryExtended!]!
    registration(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Registration
    registrations(
        skip: Int = 0
        first: Int = 100
        orderBy: Registration_orderBy
        orderDirection: OrderDirection
        where: Registration_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Registration!]!
    nameRegistered(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameRegistered
    nameRegistereds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameRegistered_orderBy
        orderDirection: OrderDirection
        where: NameRegistered_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameRegistered!]!
    nameRenewed(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameRenewed
    nameReneweds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameRenewed_orderBy
        orderDirection: OrderDirection
        where: NameRenewed_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameRenewed!]!
    nameTransferred(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameTransferred
    nameTransferreds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameTransferred_orderBy
        orderDirection: OrderDirection
        where: NameTransferred_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameTransferred!]!
    wrappedDomain(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedDomain
    wrappedDomains(
        skip: Int = 0
        first: Int = 100
        orderBy: WrappedDomain_orderBy
        orderDirection: OrderDirection
        where: WrappedDomain_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [WrappedDomain!]!
    account(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        skip: Int = 0
        first: Int = 100
        orderBy: Account_orderBy
        orderDirection: OrderDirection
        where: Account_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Account!]!
    resolver(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Resolver
    resolvers(
        skip: Int = 0
        first: Int = 100
        orderBy: Resolver_orderBy
        orderDirection: OrderDirection
        where: Resolver_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Resolver!]!
    addrChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddrChanged
    addrChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AddrChanged_orderBy
        orderDirection: OrderDirection
        where: AddrChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AddrChanged!]!
    multicoinAddrChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MulticoinAddrChanged
    multicoinAddrChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: MulticoinAddrChanged_orderBy
        orderDirection: OrderDirection
        where: MulticoinAddrChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [MulticoinAddrChanged!]!
    nameChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NameChanged
    nameChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: NameChanged_orderBy
        orderDirection: OrderDirection
        where: NameChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [NameChanged!]!
    abiChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AbiChanged
    abiChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AbiChanged_orderBy
        orderDirection: OrderDirection
        where: AbiChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AbiChanged!]!
    pubkeyChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PubkeyChanged
    pubkeyChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: PubkeyChanged_orderBy
        orderDirection: OrderDirection
        where: PubkeyChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PubkeyChanged!]!
    textChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TextChanged
    textChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: TextChanged_orderBy
        orderDirection: OrderDirection
        where: TextChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [TextChanged!]!
    contenthashChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ContenthashChanged
    contenthashChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: ContenthashChanged_orderBy
        orderDirection: OrderDirection
        where: ContenthashChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ContenthashChanged!]!
    interfaceChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): InterfaceChanged
    interfaceChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: InterfaceChanged_orderBy
        orderDirection: OrderDirection
        where: InterfaceChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [InterfaceChanged!]!
    authorisationChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuthorisationChanged
    authorisationChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: AuthorisationChanged_orderBy
        orderDirection: OrderDirection
        where: AuthorisationChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AuthorisationChanged!]!
    versionChanged(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VersionChanged
    versionChangeds(
        skip: Int = 0
        first: Int = 100
        orderBy: VersionChanged_orderBy
        orderDirection: OrderDirection
        where: VersionChanged_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [VersionChanged!]!
    domainEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DomainEvent
    domainEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: DomainEvent_orderBy
        orderDirection: OrderDirection
        where: DomainEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [DomainEvent!]!
    registrationEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegistrationEvent
    registrationEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: RegistrationEvent_orderBy
        orderDirection: OrderDirection
        where: RegistrationEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [RegistrationEvent!]!
    resolverEvent(
        id: ID!

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ResolverEvent
    resolverEvents(
        skip: Int = 0
        first: Int = 100
        orderBy: ResolverEvent_orderBy
        orderDirection: OrderDirection
        where: ResolverEvent_filter

        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [ResolverEvent!]!

    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

type TextChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    key: String!
    value: String
}

input TextChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    key: String
    key_not: String
    key_gt: String
    key_lt: String
    key_gte: String
    key_lte: String
    key_in: [String!]
    key_not_in: [String!]
    key_contains: String
    key_contains_nocase: String
    key_not_contains: String
    key_not_contains_nocase: String
    key_starts_with: String
    key_starts_with_nocase: String
    key_not_starts_with: String
    key_not_starts_with_nocase: String
    key_ends_with: String
    key_ends_with_nocase: String
    key_not_ends_with: String
    key_not_ends_with_nocase: String
    value: String
    value_not: String
    value_gt: String
    value_lt: String
    value_gte: String
    value_lte: String
    value_in: [String!]
    value_not_in: [String!]
    value_contains: String
    value_contains_nocase: String
    value_not_contains: String
    value_not_contains_nocase: String
    value_starts_with: String
    value_starts_with_nocase: String
    value_not_starts_with: String
    value_not_starts_with_nocase: String
    value_ends_with: String
    value_ends_with_nocase: String
    value_not_ends_with: String
    value_not_ends_with_nocase: String

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [TextChanged_filter]
    or: [TextChanged_filter]
}

enum TextChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    key
    value
}

type Transfer implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    owner: Account!
}

input Transfer_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Transfer_filter]
    or: [Transfer_filter]
}

enum Transfer_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    owner
    owner__id
}

type VersionChanged implements ResolverEvent {
    id: ID!
    resolver: Resolver!
    blockNumber: Int!
    transactionID: Bytes!
    version: BigInt!
}

input VersionChanged_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    resolver: String
    resolver_not: String
    resolver_gt: String
    resolver_lt: String
    resolver_gte: String
    resolver_lte: String
    resolver_in: [String!]
    resolver_not_in: [String!]
    resolver_contains: String
    resolver_contains_nocase: String
    resolver_not_contains: String
    resolver_not_contains_nocase: String
    resolver_starts_with: String
    resolver_starts_with_nocase: String
    resolver_not_starts_with: String
    resolver_not_starts_with_nocase: String
    resolver_ends_with: String
    resolver_ends_with_nocase: String
    resolver_not_ends_with: String
    resolver_not_ends_with_nocase: String
    resolver_: Resolver_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    version: BigInt
    version_not: BigInt
    version_gt: BigInt
    version_lt: BigInt
    version_gte: BigInt
    version_lte: BigInt
    version_in: [BigInt!]
    version_not_in: [BigInt!]

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [VersionChanged_filter]
    or: [VersionChanged_filter]
}

enum VersionChanged_orderBy {
    id
    resolver
    resolver__id
    resolver__address
    resolver__contentHash
    blockNumber
    transactionID
    version
}

type WrappedDomain {
    id: ID!
    domain: Domain!
    expiryDate: BigInt!
    fuses: Int!
    owner: Account!
    name: String
}

input WrappedDomain_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    expiryDate: BigInt
    expiryDate_not: BigInt
    expiryDate_gt: BigInt
    expiryDate_lt: BigInt
    expiryDate_gte: BigInt
    expiryDate_lte: BigInt
    expiryDate_in: [BigInt!]
    expiryDate_not_in: [BigInt!]
    fuses: Int
    fuses_not: Int
    fuses_gt: Int
    fuses_lt: Int
    fuses_gte: Int
    fuses_lte: Int
    fuses_in: [Int!]
    fuses_not_in: [Int!]
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [WrappedDomain_filter]
    or: [WrappedDomain_filter]
}

enum WrappedDomain_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    expiryDate
    fuses
    owner
    owner__id
    name
}

type WrappedTransfer implements DomainEvent {
    id: ID!
    domain: Domain!
    blockNumber: Int!
    transactionID: Bytes!
    owner: Account!
}

input WrappedTransfer_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    domain: String
    domain_not: String
    domain_gt: String
    domain_lt: String
    domain_gte: String
    domain_lte: String
    domain_in: [String!]
    domain_not_in: [String!]
    domain_contains: String
    domain_contains_nocase: String
    domain_not_contains: String
    domain_not_contains_nocase: String
    domain_starts_with: String
    domain_starts_with_nocase: String
    domain_not_starts_with: String
    domain_not_starts_with_nocase: String
    domain_ends_with: String
    domain_ends_with_nocase: String
    domain_not_ends_with: String
    domain_not_ends_with_nocase: String
    domain_: Domain_filter
    blockNumber: Int
    blockNumber_not: Int
    blockNumber_gt: Int
    blockNumber_lt: Int
    blockNumber_gte: Int
    blockNumber_lte: Int
    blockNumber_in: [Int!]
    blockNumber_not_in: [Int!]
    transactionID: Bytes
    transactionID_not: Bytes
    transactionID_gt: Bytes
    transactionID_lt: Bytes
    transactionID_gte: Bytes
    transactionID_lte: Bytes
    transactionID_in: [Bytes!]
    transactionID_not_in: [Bytes!]
    transactionID_contains: Bytes
    transactionID_not_contains: Bytes
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_: Account_filter

    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [WrappedTransfer_filter]
    or: [WrappedTransfer_filter]
}

enum WrappedTransfer_orderBy {
    id
    domain
    domain__id
    domain__name
    domain__labelName
    domain__labelhash
    domain__subdomainCount
    domain__ttl
    domain__isMigrated
    domain__createdAt
    blockNumber
    transactionID
    owner
    owner__id
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
